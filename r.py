print("running dr.py")

# -*- coding: utf-8 -*-
"""c122_digitRecognition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PsXAgYusj1wAkiwAusrQILf_sizWqvWj
"""

# -*- coding: utf-8 -*-
"""c122proj_alphabetRecognition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iaeS4vpAIKrNrCAusReBOMhyjl57oXcx
"""

import cv2
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.datasets import fetch_openml
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
import os
import ssl
from PIL import Image
import PIL.ImageOps
import time

if (not os.environ.get("PYTHONHTTPSVERIFY", "") and getattr(ssl, "_create_unverified_context", None)):
    ssl._create_default_https_context = ssl._create_unverified_context

x = np.load('image.npz')['arr_0']
y = pd.read_csv('labels.csv')['labels']

print(pd.Series(y).value_counts())

classes = [i for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ']

print(x[0])
print(y[0])

sample_size = 5

n = len(classes)

index_class = 0

for c in classes:
  index = np.flatnonzero(y==c)
  index = np.random.choice(index, sample_size, False)
  t = 0
  for i in index:
    t += 1
  index_class += 1

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=2500, train_size=7500, random_state=1)

x_train_scaled = x_train/255.0
x_test_scaled = x_test/255.0

print("fitting model...")
model = LogisticRegression(solver="saga", multi_class="multinomial").fit(x_train_scaled, y_train)
print("model done fitting!")

y_pred = model.predict(x_test_scaled)

acc = accuracy_score(y_test, y_pred)
print(acc)

# cm = pd.crosstab(y_test, y_pred, rownames=["actual"], colnames=["predicted"])
# p = plt.figure(figsize=(10, 10))
# p = sns.heatmap(cm, annot=True, fmt="d", cbar=False)


cap = cv2.VideoCapture(0)

c = 0

# while True:
#     try:
#         c += 1
#         ret, frame = cap.read()
#         gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
#         height, width = gray.shape
#         upperLeft = (int(width/2 - 56), int(height/2 - 56))
#         bottomRight = (int(width/2 + 56), int(height/2 + 56))
#         cv2.rectangle(gray, upperLeft, bottomRight, (0, 255, 0), 2)
#         region = gray[upperLeft[1]:bottomRight[1], upperLeft[0]:bottomRight[0]]
#         imPIL = Image.fromarray(region)
#         lFormat = imPIL.convert("L")
#         lFormat = lFormat.resize((22, 30), 1)
#         lFormat = PIL.ImageOps.invert(lFormat)
#         pixelFilter = 20
#         minPixels = np.percentile(lFormat, pixelFilter)
#         maxPixels = np.max(lFormat)
#         lFormat = np.clip(lFormat - minPixels, 0, 255)
#         lFormat = np.asarray(lFormat)/maxPixels
#         lFormat = np.array(lFormat).reshape(1, 660)
#         prediction = model.predict(lFormat)
#         print(prediction)
#         if (cv2.waitKey(1) & 0xFF == ord("q")):
#             break
#     except Exception as e:
#         print(e)

def get_prediction(img):
    try:
        imPIL = Image.open(img)
        lFormat = imPIL.convert("L")
        lFormat = lFormat.resize((22, 30), 1)
        lFormat = PIL.ImageOps.invert(lFormat)
        pixelFilter = 20
        minPixels = np.percentile(lFormat, pixelFilter)
        maxPixels = np.max(lFormat)
        lFormat = np.clip(lFormat - minPixels, 0, 255)
        lFormat = np.asarray(lFormat)/maxPixels
        lFormat = np.array(lFormat).reshape(1, 660)
        prediction = model.predict(lFormat)
        return prediction[0]
    except Exception as e:
        return "?"

cap.release()
cv2.destroyAllWindows()